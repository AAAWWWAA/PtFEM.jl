<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PtFEM.jl documentation · PtFEM</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PtFEM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="INTRO.html">Introduction</a></li><li><a class="toctext" href="GETTINGSTARTED.html">Getting started</a></li><li><a class="toctext" href="CHANGES.html">Changes w.r.t. PtFEM</a></li><li class="current"><a class="toctext" href="index.html">PtFEM.jl documentation</a><ul class="internal"><li><a class="toctext" href="#Static-Equilibrium-Programs-1">4 Static Equilibrium Programs</a></li><li><a class="toctext" href="#Elastic-Solids-Programs-1">5 Elastic Solids Programs</a></li><li><a class="toctext" href="#Material-Nonlinearity-Programs-1">6 Material Nonlinearity Programs</a></li><li><a class="toctext" href="#Structural-Element-Types-1">Structural Element Types</a></li><li><a class="toctext" href="#Finite-Element-Types-1">Finite Element Types</a></li><li><a class="toctext" href="#Other-Julia-Types-1">Other Julia Types</a></li><li><a class="toctext" href="#PtFEM-Main-1">PtFEM - Main</a></li><li><a class="toctext" href="#PtFEM-Geom-1">PtFEM - Geom</a></li><li><a class="toctext" href="#PtFEM-Plot-methods-1">PtFEM - Plot methods</a></li><li><a class="toctext" href="#PtFEM-VTK-methods-1">PtFEM - VTK methods</a></li><li><a class="toctext" href="#PtFEM-Julia-functions-and-operators-1">PtFEM - Julia functions &amp; operators</a></li><li><a class="toctext" href="#PtFEM-Parallel-processing-1">PtFEM - Parallel processing</a></li><li><a class="toctext" href="#PtFEM-Deprecated-1">PtFEM - Deprecated</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li><li><a class="toctext" href="VERSIONS.html">Versions</a></li><li><a class="toctext" href="TODO.html">Todo</a></li><li><a class="toctext" href="REFERENCES.html">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">PtFEM.jl documentation</a></li></ul><a class="edit-page" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PtFEM.jl documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Programs-1" href="#Programs-1">Programs</a></h1><h2><a class="nav-anchor" id="Static-Equilibrium-Programs-1" href="#Static-Equilibrium-Programs-1">4 Static Equilibrium Programs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p41" href="#PtFEM.p41"><code>PtFEM.p41</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Method p41</strong></p><p>One dimensional analysis of an axially loaded elastic Rod using 2-node  Line elements. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p41(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Rod                           : Help on a Rod structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p41.jl#L1-L49">source</a><br/><div><p><strong>Method p41</strong></p><p>One dimensional analysis of an axially loaded elastic Rod using 2-node  Line elements. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p41(m, data) # Re-use factored global stiffness matrix</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `m::jFEM`                  : Previously created jFEM model
* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Rod                           : Help on a Rod structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p41.jl#L270-L319">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p42-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p42-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p42</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p42</strong></p><p>Analysis of elastic pin-jointed frames using 2-node rod elements in 2- or 3-dimensions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p42(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::Vector{Float64}                            : x coordinate vector
* y_coords::Vector{Float64}                            : y coordinate vector
* g_num::Array{Int,2}                                : Element node connections</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* penalty::Float64             : Penalty for fixed freedoms
* etype::Vector{Int}         : Element material vector
* z_coords::Vector{Float64}    : z coordinate vector (3D)
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural element types
?Frame              : Help on a Rod structural fin_el
?FiniteElement      : List finite element types
?Line               : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p42.jl#L1-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p43-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p43-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p43</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>p43</strong></p><p>Analysis of elastic beams using 2-node Beam structural elements and Line finite elements. Elastic foundation is optional.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p43(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::LinSpace{Float64}                          : x coordinate vector
* g_num::Array{Int,2}                                : Element node connections
* fixed_freedoms::Array{Tuple{Vector{Int}}           : Fixed freedoms</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int}                                 : Element material vector
* penalty::Float64                                     : Penalty for fixed freedoms
* eq_nodal_forces_and_moments                          : Equivalent nodal loads</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?Rod                : Help on a Rod structural fin_el
?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p43.jl#L1-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p44-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p44-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p44</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>p44</strong></p><p>Analysis of elastic rigid-jointed frames using a 2-node Frame structural element and Line finite elements in 2 or 3 dimensions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p44(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x coordinate vector
* y_coords::FloatRange{Float64}                        : y coordinate vector
* g_num::Array{Int,2}                                : Element node connections
* fixed_freedoms::Array{Tuple{Vector{Int}}           : Fixed freedoms</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int}                                 : Element material vector
* penalty::Float64                                     : Penalty for fixed freedoms
* z_coords::FloatRange{Float64}                        : z coordinate vector
* eq_nodal_forces_and_moments                          : Equivalent nodal loads</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?Beam               : Help on a Beam structural fin_el
?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p44.jl#L1-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p45-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p45-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p45</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p45</strong></p><p>Analysis of elasto-plastic beams or rigid-jointed frames using a 2-node Frame structural element in 1, 2 or 3 dimensions. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p45(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector
* dload::FloatRange{Float64}                           : load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20                 : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}           : Element material vector if np_types &gt; 1
* y_coords::FloatRange{Float64}  : y-coordinate vector (2D)
* z_coords::FloatRange{Float64}  : x-coordinate vector (3D)
* limit = 250                    : Iteration limit
* tol = 0.0001                   : Tolerance for iteration convergence</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Frame                         : Help on a Frame structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p45.jl#L1-L43">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p46-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p46-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p46</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p46</strong></p><p>Stability (buckling) analysis of elastic beams using a 2-node Beam structural element and Line finite elements. Elastic foundation is optional.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p46(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* limit = 250                  : Iteration limit
* tol = 0.0001                 : Tolerance for iteration convergence</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Beam                          : Help on a Beam structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p46.jl#L1-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p47-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p47-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p47</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p47</strong></p><p>Analysis of plates (Plane structural element) using 4-node Quadrilateral finite elements. Homogeneous material with identical elements. Mesh numbered in x or y direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p47(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (fm_dt, sigma_dt)            : Tuple of jFem, dis_dt and fm_dt
                                  where:
                                    fm_dt         : Forces and moments data table
                                    sigma_dt      : Stresses data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/4 Static Equilibrium/p47.jl#L1-L49">source</a><br/></section><h2><a class="nav-anchor" id="Elastic-Solids-Programs-1" href="#Elastic-Solids-Programs-1">5 Elastic Solids Programs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p51-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p51-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p51</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p51</strong></p><p>Plane or axisymmetric strain analysis of an elastic solid (Plane structural element) using 3-, 6-, 10- or 15-node right-angled triangles (Triangle finite elements) or 4-, 8- or 9-node rectangular quadrilaterals (Quadrilateral finite elements). Mesh numbered in x(r)- or y(z)- direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p51(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}            : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1}   : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20             : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (fem, fm_dt, sigma_dt)     : Tuple of jFem, dis_dt and fm_dt
                               where:
                                 fm_dt         : Forces and moments data table
                                 sigma_dt      : Stresses data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement           : List of available structural element types
?Plane                       : Help on a Plane structural element
?FiniteElement               : List finite element types
?Quadrilateral               : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/5 Elastic Solids/p51.jl#L1-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p52-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p52-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p52</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p52</strong></p><p>Non-axisymmetric analysis of an axisymmetric elastic solid using 8-node rectangular quadrilaterals. Mesh numbered in r- or z- direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p52(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}            : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1}   : Node load vector
* properties::Vector{Float64}                          : Material properties</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20             : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1
* lth::Int                   :
* iflag::Int                 :
* chi::Float64               :</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (fem, fm_dt, sigma_dt)     : Tuple of jFem, dis_dt and fm_dt
                               where:
                                 fm_dt         : Forces and moments data table
                                 sigma_dt      : Stresses data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement           : List of available structural element types
?Plane                       : Help on a Plane structural element
?FiniteElement               : List finite element types
?Quadrilateral               : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/5 Elastic Solids/p52.jl#L1-L49">source</a><br/></section><h2><a class="nav-anchor" id="Material-Nonlinearity-Programs-1" href="#Material-Nonlinearity-Programs-1">6 Material Nonlinearity Programs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p61-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p61-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p61</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p61</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (von Mises) material using 8-node rectangular quadrilaterals. Viscoplastic strain method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p61(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate
* tol::Float64                                         : Convergence tolerance
* qincs::Vector{Float64}                               : Incremental load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* limit = 250                  : Iteration limit
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/6 Material Nonlinearity/p61.jl#L1-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p62-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p62-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p62</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p62</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (von Mises) material using 8-node rectangular quadrilaterals.</p><p>Viscoplastic strain method.</p><p>No global stiffness matrix assembly.</p><p>Diagonally preconditioned conjugate gradient solver.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p62(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int,Array{Int,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate
* tol::Float64                                         : Convergence tolerance
* qincs::Vector{Float64}                               : Incremental load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* limit = 250                  : Iteration limit
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/6 Material Nonlinearity/p62.jl#L1-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p63-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p63-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p63</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p63</strong></p><p>Plane strain bearing capacity analysis of an elastic-plastic (Mohr-Coulomb) material using 8-node rectangular quadrilaterals. Rigid smooth footing. Displacement control. Viscoplastic strain method.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p63(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* tol::Float64                 : Convergence tolerance
* limit = 250                  : Iteration limit
* incs::Int                    : Incremental load steps
* presc::Float64               : Wall displacement increment
* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int}           : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (g_coord, g_num, disp)        : where:
                                    g_coord  : Coordinates
                                    g_num    : Node numbering
                                    disp     : Matrix of displacements</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/6 Material Nonlinearity/p63.jl#L1-L50">source</a><br/></section><h2><a class="nav-anchor" id="Structural-Element-Types-1" href="#Structural-Element-Types-1">Structural Element Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.StructuralElement" href="#PtFEM.StructuralElement"><code>PtFEM.StructuralElement</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>StructuralElement</strong></p><p>Abstract structural element type.</p><p><strong>Type</strong></p><pre><code class="language-julia">abstract StructuralElement</code></pre><p><strong>Subtypes</strong></p><pre><code class="language-julia">* Rod::StructuralElement          : Rod(nxe, np_types, nip, fin_el)
* Beam::StructuralElement         : Beam(nod, nodof)
* Frame::StructuralElement        : Frame(nod, nodof)
* Plane::StructuralElement        : Plane(nod, nodof)
* Solid::StructuralElement        : Solid(nod, nodof)
* GenericSolid::StructuralElement : GenericSolid(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement                    : Show all finite elements
?Rod                              : Help on Rod structural element
?Beam                             : Help on Beam structural element
?Frame                            : Help on Frame structural element
?Plane                            : Help on Plane structural element
?Solid                            : Help on Solid structural element
?GenericSolid                     : Help on GenericSolid structural element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L3-L33">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Rod" href="#PtFEM.Rod"><code>PtFEM.Rod</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Rod</strong></p><p>Concrete 1D structural element with only axial stresses.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Rod(nels, np_types, nip, fin_el)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nels::Int             : Number of fin_els (stored in field nxe)
* np_types::Int         : Number of different property types
* nip::Int              : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?FiniteElement      : Help on finite element types
?Line               : Help on a Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L36-L60">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Beam" href="#PtFEM.Beam"><code>PtFEM.Beam</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Beam</strong></p><p>Concrete structural element with transverse and moment loading.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Beam(ndim, nip, fin_el)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int             : Number of dimensions
* nst::Int              : Number of stress terms
* nxe::Int              : Number of different property types
* nip::Int              : Number of integration points
* direction::Symbol     : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)
* axisymmetric::Bool    : Axisymmetric if true</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?FiniteElement      : Help on finite element types
?Line               : Help on a Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L68-L95">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Frame" href="#PtFEM.Frame"><code>PtFEM.Frame</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Frame</strong></p><p>Pin- or rigid-jointed structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Frame(nels, nn, ndim, finite_element(nod, nodof))</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nels::Int             : Number of elements
* nn:Int                : Number of nodes
* ndim::Int             : Number of dimensions
* nst::Int              : Number of stress terms
* nip::Int              : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types
?Line               : Help on a Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L106-L132">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Plane" href="#PtFEM.Plane"><code>PtFEM.Plane</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Plane</strong></p><p>Plate structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Plane(ndim, nst, nxe, nye, nip, dir, finite_element(nod, nodof), axisymmetric)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int               : Number of dimensions
* nst::Int                : Number of stress terms
* nxe::Int                : Number of elements in x direction
* nye::Int                : Number of elements in y direction
* nip::Int                : Number of integration points
* dir::Symbol             : Direction of node numbering
* fin_el::FiniteElement   : Line(nod, nodof)
* axisymmetric::Bool      : Axisymmetric</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types
?Line               : Help on a Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L142-L170">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Solid" href="#PtFEM.Solid"><code>PtFEM.Solid</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Solid</strong></p><p>Solid structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Solid(ndim, nst, nxe, nye, nze, nip, finite_element(nod, nodof))</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int             : Number of dimensions
* nst::Int              : Number of stress terms
* nxe::Int              : Number of elements in x direction
* nye::Int              : Number of elements in y direction
* nze::Int              : Number of elements in z direction
* nip::Int              : Number of integration points
* fin_el::FiniteElement : Line(nod, nodof)</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L182-L208">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.GenericSolid" href="#PtFEM.GenericSolid"><code>PtFEM.GenericSolid</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>GenericSolid</strong></p><p>Solid structural element.</p><p><strong>Constructor</strong></p><pre><code class="language-julia">GenericSolid(ndim, nst, nels, nn, nip, finite_element(nod, nodof), axisymmetric)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ndim::Int               : Number of dimensions
* nst::Int                : Number of stress terms
* nels::Int               : Number of finite elements
* nn::Int                 : Number of nodes
* nip::Int                : Number of integration points
* fin_el::FiniteElement   : Finite element type used
* axisymmetric::Bool      : Axisymmetric</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural elements
?FiniteElement      : List finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/structural_elements.jl#L219-L245">source</a><br/></section><h2><a class="nav-anchor" id="Finite-Element-Types-1" href="#Finite-Element-Types-1">Finite Element Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.FiniteElement" href="#PtFEM.FiniteElement"><code>PtFEM.FiniteElement</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>FiniteElement</strong></p><p>Abstract finite element type.</p><p><strong>Type</strong></p><pre><code class="language-julia">abstract FiniteElement</code></pre><p><strong>Subtypes</strong></p><pre><code class="language-julia">* Line::FiniteElement          : 1D Line(nod, nodof)
* Triangle::FiniteElement      : 2D Triangle(nod, nodof)
* Quadrilateral::FiniteElement : 2D Quadrilateral(nod, nodof)
* Hexahedron::FiniteElement    : 3D Hexahedron(nod, nodof)
* Tetrahedron::FiniteElement   : 3D Tetrahedron(nod, nodof)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/finite_elements.jl#L5-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Line" href="#PtFEM.Line"><code>PtFEM.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Line (Interval)</strong></p><p>1D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Line(nod, nodof)
Line(nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element, defaults to 2
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/finite_elements.jl#L26-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Triangle" href="#PtFEM.Triangle"><code>PtFEM.Triangle</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Triangle</strong></p><p>2D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Triangle(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (3, 6, 10, 15)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/finite_elements.jl#L55-L76">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Quadrilateral" href="#PtFEM.Quadrilateral"><code>PtFEM.Quadrilateral</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Quadrilateral</strong></p><p>2D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Quadrilateral(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (4, 8, 9)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/finite_elements.jl#L82-L103">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Hexahedron" href="#PtFEM.Hexahedron"><code>PtFEM.Hexahedron</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>hexahedron</strong></p><p>3D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Hexahedron(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (8, 14, 20)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/finite_elements.jl#L138-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Tetrahedron" href="#PtFEM.Tetrahedron"><code>PtFEM.Tetrahedron</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Tetrahedron</strong></p><p>3D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Tetrahedron(nod, nodof)
Tetrahedron(nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int       : Number of nodes for finite element (defaults to 4)
* nodof::Int     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/finite_elements.jl#L109-L131">source</a><br/></section><h2><a class="nav-anchor" id="Other-Julia-Types-1" href="#Other-Julia-Types-1">Other Julia Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.FEM" href="#PtFEM.FEM"><code>PtFEM.FEM</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>FEM</strong></p><p>Computational structure used in chapter 5 (Skyline format used)</p></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/FEM.jl#L5-L10">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.jFEM" href="#PtFEM.jFEM"><code>PtFEM.jFEM</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>jFEM</strong></p><p>Computational structure used in chapter 4 (Julia Sparse matrices used)</p></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Types/FEM.jl#L86-L91">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Main-1" href="#PtFEM-Main-1">PtFEM - Main</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beam_gm-Tuple{Float64}" href="#PtFEM.beam_gm-Tuple{Float64}"><code>PtFEM.beam_gm</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>beam_gm</strong></p><p>This subroutine forms the beam geometric matrix for stability analysis.</p><p><strong>Method</strong></p><pre><code class="language-julia">beam_gm(ell::Float64)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ell::Float64                   : Element length</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* gm::::Matrix{Float64}(4,4)     : Geometric matrix for beam element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/beam_gm.jl#L1-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beam_km-Tuple{Float64,Float64}" href="#PtFEM.beam_km-Tuple{Float64,Float64}"><code>PtFEM.beam_km</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>beam_km</strong></p><p>This subroutine forms the stiffness matrix of a beam element (bending only).</p><p><strong>Method</strong></p><pre><code class="language-julia">beam_km(ei, ell)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* ei::Float64               : Element stiffness
* ell::Float64              : Element length</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* km::::Matrix{Float64}     : Stiiness matrix for beam element (Updated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/beam_km.jl#L1-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beam_mm-Tuple{Float64,Float64}" href="#PtFEM.beam_mm-Tuple{Float64,Float64}"><code>PtFEM.beam_mm</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>beam_mm</strong></p><p>This subroutine forms the stiffness matrix of a beam element (bending only).</p><p><strong>Method</strong></p><pre><code class="language-julia">beam_mm(ei, ell)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fs::Float64               : Element density
* ell::Float64              : Element length</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* mm::::Matrix{Float64}     : Mass matrix for beam elembeam_mmated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/beam_mm.jl#L1-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.beemat!-Tuple{Array{Float64,2},Array{Float64,2}}" href="#PtFEM.beemat!-Tuple{Array{Float64,2},Array{Float64,2}}"><code>PtFEM.beemat!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>beemat!</strong></p><p>This subroutine forms the strain-displacement matrix for axisymmetric solids subjected to non-axisymmetric loading.</p><p><strong>Method</strong></p><pre><code class="language-julia">beemat!(bee, deriv)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* bee::Matrix{Float64}         : Bee matrix (Updated)
* deriv::Matrix{Float64}       : Derivative</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/beemat.jl#L1-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.bmat_nonaxi!-Tuple{Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2},Array{Float64,1},Int64,Int64}" href="#PtFEM.bmat_nonaxi!-Tuple{Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2},Array{Float64,1},Int64,Int64}"><code>PtFEM.bmat_nonaxi!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>bmat_nonaxi!</strong></p><p>This subroutine forms the strain-displacement matrix for axisymmetric solids subjected to non-axisymmetric loading.</p><p><strong>Method</strong></p><pre><code class="language-julia">bmat_nonaxi!(bee, radius, coord, deriv, fun, iflag, lth)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* bee::Matrix{Float64}         : Bee matrix (Updated)
* radius::Float64              : r coordinate of the Gauss point
* coord::Matrix{Float64}       : Nodal coordinate matrix
* deriv::Matrix{Float64}       : Derivative
* fun::Vector{Float64}         : Shape function
* iflag::Int                 : 1 = symmetric, -1 = anti-symmetric
* lth::Int                   : Harmonic</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/bmat_nonaxi.jl#L1-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.checon-Tuple{Array{Float64,1},Array{Float64,1},Float64}" href="#PtFEM.checon-Tuple{Array{Float64,1},Array{Float64,1},Float64}"><code>PtFEM.checon</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>checon</strong></p><p>This subroutine sets converged to .FALSE. if relative change in loads and oldlds is greater than tol and updates oldlds.</p><p><strong>Method</strong></p><pre><code class="language-julia">checon(loads, oldlds, tol)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* loads::Vector{Float64}        : Displacements vector/OffsetArray
* oldlds::Vector{Float64}       : Previous displacement vector/OffsetArray
* tol::Float64                  : Convergence tolerance</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* ::Bool                        : Convergence achieved</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/checon.jl#L1-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.deemat!-Tuple{Array{Float64,2},Float64,Float64}" href="#PtFEM.deemat!-Tuple{Array{Float64,2},Float64,Float64}"><code>PtFEM.deemat!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>deemat!</strong></p><p>This subroutine returns the elastic dee matrix for ih=3 (plane strain), ih=4 (axisymmetry or plane strain elastoplasticity) or ih=6 (three dimensions).</p><p><strong>Method</strong></p><pre><code class="language-julia">deemat!(dee, e, v)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* dee::Matrix{Float64}         : Dee matrix (Updated)
* e::Float64                   : Young&#39;s modulus
* v::Float64                   : Poisson&#39;s ratio</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/deemat.jl#L1-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fkdiag!-Tuple{Array{Int64,1},Array{Int64,1}}" href="#PtFEM.fkdiag!-Tuple{Array{Int64,1},Array{Int64,1}}"><code>PtFEM.fkdiag!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>fkdiag!</strong></p><p>This subroutine returns the elastic dee matrix for ih=3 (plane strain), ih=4 (axisymmetry or plane strain elastoplasticity) or ih=6 (three dimensions).</p><p><strong>Method</strong></p><pre><code class="language-julia">fkdiag!(kdiag, g)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kdiag::Vector{Int}      : Bandwidth vector (Updated)
* g::Vector{Int}          : Element steering vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/fkdiag.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fmplat!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Float64,Float64,Int64}" href="#PtFEM.fmplat!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Float64,Float64,Int64}"><code>PtFEM.fmplat!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>fmplat!</strong></p><p>This subroutine forms the 2nd derivatives for rectangular plate bending fin_els.</p><p><strong>Method</strong></p><pre><code class="language-julia">fmplat!(d2x, d2y, d2xy, points, aa, bb, i)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* d2x::Vector{Float64}       : x derivative term (Updated)
* d2y::Vector{Float64}       : y derivative term (Updated)
* d2xy::Vector{Float64}      : x,y derivative term (Updated)
* points::Matrix{Float64}    : Location of Gauss points
* aa::Float64                : Dimension of plate
* bb::Float64                : Dimension of plate
* i::Int                   : Gauss point to use</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/fmplat.jl#L1-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.formm!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,2}}" href="#PtFEM.formm!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>PtFEM.formm!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>formm!</strong></p><p>This subroutine forms the derivatives of the invariants with respect to stress in 2- or 3-d. See equation 6.25.</p><p><strong>Function</strong></p><pre><code class="language-julia">formm!(stress, m1, m2, m3)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* stress::Vector{Float64}    : Stress vector, see eq 6.25
* m1::Matrix{Float64}        : m1 matrix
* m2::Matrix{Float64}        : m2 matrix
* m3::Matrix{Float64}        : m3 matrix</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* m1::Matrix{Float64}        : m1 matrix
* m2::Matrix{Float64}        : m2 matrix
* m3::Matrix{Float64}        : m3 matrix</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/formm.jl#L1-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.formnf!-Tuple{Int64,Int64,Array{Int64,2}}" href="#PtFEM.formnf!-Tuple{Int64,Int64,Array{Int64,2}}"><code>PtFEM.formnf!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>formnf!</strong></p><p>Returns nodal freedom numbering array nf</p><p><strong>Function</strong></p><pre><code class="language-julia">formnf!(nodof, nn, nf)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nodof::Int       : Number of degrees of freedom for each node
* nn::Int          : Number of nodes in mesh
* nf::Array{Int,2} : Nodal freedom matrix (updated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/formnf.jl#L1-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fsparm!-Tuple{Any,Any,Any}" href="#PtFEM.fsparm!-Tuple{Any,Any,Any}"><code>PtFEM.fsparm!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>fsparm!</strong></p><p>Function fsparm assembles fin_el matrices into a Julia sparse global stiffness matrix.</p><p><strong>Method</strong></p><pre><code class="language-julia">fsparm!(gsm, g, km)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* gsm::SparseArrays{Float64, Float64}   : Sparse stiffnes matrix (Updated)
* g::Vector{Int}                      : Global coordinate vector.
* km::Matrix{Float64}                   : Stiffness matrix.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/fsparm.jl#L1-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.glob_to_loc!-Tuple{Array{Float64,1},Array{Float64,1},Float64,Array{Float64,2}}" href="#PtFEM.glob_to_loc!-Tuple{Array{Float64,1},Array{Float64,1},Float64,Array{Float64,2}}"><code>PtFEM.glob_to_loc!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>glob_to_loc!</strong></p><p>This subroutine transforms the global end reactions and moments into the local system (2- or 3-d). Called from hinge!().</p><p><strong>Function</strong></p><pre><code class="language-julia">glob_to_loc!(loc, glob, gamma, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* loc::Vector{Float64}       : Local force and momemts (Updated)
* glob::Vector{Float64}      : Globale forces and moments
* gamma::Float64             : Element orientation angle (3D)
* coord::Matrix{Float64}     : Nodal coordinates</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/global_to_local.jl#L1-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.glob_to_axial-Tuple{Array{Float64,1},Array{Float64,2}}" href="#PtFEM.glob_to_axial-Tuple{Array{Float64,1},Array{Float64,2}}"><code>PtFEM.glob_to_axial</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>glob_to_axial</strong></p><p>This subroutine transforms the global end reactions into an axial force for rod fin_els (2- or 3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">glob_to_axial(glob, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* glob::Vector{Float64}      : Globale forces and moments
* coord::Matrix{Float64}     : Nodal coordinates</code></pre><p><strong>REturn value</strong></p><pre><code class="language-julia">* ::Float64                  : Axial force</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/global_to_axial.jl#L1-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.hinge!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,1},Array{Float64,1},Array{Float64,2},Any,Array{Int64,1},Array{Float64,1}}" href="#PtFEM.hinge!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,1},Array{Float64,1},Array{Float64,2},Any,Array{Int64,1},Array{Float64,1}}"><code>PtFEM.hinge!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>hinge!</strong></p><p>This subroutine forms the end forces and moments to be applied to a member if a joint has gone plastic.</p><p><strong>Function</strong></p><pre><code class="language-julia">hinge!(coord, holdr, action, react, prop, iel, etype, gamma)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* coord::Matrix{Float64}     : Nodal coordinates
* holdr::Matrix{Float64}     : Existing reactions
* action::Vector{Float64}    : Incremental reactions
* react::Vector{Float64}     : Correction to reactions (Updated)
* prop::Matrix{Float64}      : Beam properties
* iel::Int                 : Element number
* etype::Vector{Int}       : Element type
* gamma::Vector{Float64}     : Element orientation (3D)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/hinge.jl#L1-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.invar-Tuple{Array{Float64,1},Float64,Float64,Float64}" href="#PtFEM.invar-Tuple{Array{Float64,1},Float64,Float64,Float64}"><code>PtFEM.invar</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>invar</strong></p><p>This subroutine forms the stress invariants in 2- or 3-d. See equations 6.3 and 6.4</p><p><strong>Function</strong></p><pre><code class="language-julia">invar(stress, sigm, dsbar, theta)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* stress::Vector{Float64}    : Stress vector
* sigm::Float64              : Invariant, eq 6.4 (Updated)
* dsbar::Float64             : Invariant, eq 6.4 (Updated)
* theta::Float64             : Invariant, eq 6.3 (Updated)</code></pre><p><strong>REturn values</strong></p><pre><code class="language-julia">* stress::Vector{Float64}    : Stress vector
* sigm::Float64              : Invariant, eq 6.4 (Updated)
* dsbar::Float64             : Invariant, eq 6.4 (Updated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/invar.jl#L1-L27">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.linmul_sky!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}" href="#PtFEM.linmul_sky!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}"><code>PtFEM.linmul_sky!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>linmul_sky!</strong></p><p>This subroutine forms the product of symmetric matrix stored as a skyline and a vector.</p><p><strong>Method</strong></p><pre><code class="language-julia">linmul_sky!(kv, disps, loads, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Sparse stiffnes matrix (Skyline format)
* disps::Vector{Float64}    : Displacements
* loads::Vector{Float64}    : Loads vector (Updated)
* kdiag::Vector{Int}      : Bandwidth vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/linmul_sky.jl#L1-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.loc_to_glob!-Tuple{Array{Float64,1},Array{Float64,1},Float64,Array{Float64,2}}" href="#PtFEM.loc_to_glob!-Tuple{Array{Float64,1},Array{Float64,1},Float64,Array{Float64,2}}"><code>PtFEM.loc_to_glob!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>loc_to_glob!</strong></p><p>This subroutine transforms the local end reactions and moments into the global system (3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">loc_to_glob!(loc, glob, gamma, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* loc::Vector{Float64}       : Local force and momemts (Updated)
* glob::Vector{Float64}      : Globale forces and moments
* gamma::Float64             : Element orientation angle (3D)
* coord::Matrix{Float64}     : Nodal coordinates</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/local_to_global.jl#L1-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mocouf-NTuple{5,Any}" href="#PtFEM.mocouf-NTuple{5,Any}"><code>PtFEM.mocouf</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>mocouf</strong></p><p>This subroutine calculates the value of the yield function for a Mohr-Coulomb material (phi in degrees).</p><p><strong>Function</strong></p><pre><code class="language-julia">mocouf(phi, c, sigm, dsbar, theta)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* psi::Float64              : Local force and momemts (Updated)
* c::Float64                : Globale forces and moments
* sigm::Float64             : Element orientation angle (3D)
* dsbar::Float64            : Globale forces and moments
* theta::Float64            : Element orientation angle (3D)</code></pre><p><strong>Return value</strong></p><pre><code class="language-julia">* ::Float64                 : Value of yield function</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/mocouf.jl#L1-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mocouq-Tuple{Any,Any,Any}" href="#PtFEM.mocouq-Tuple{Any,Any,Any}"><code>PtFEM.mocouq</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>mocouq</strong></p><p>This subroutine forms the derivatives of a Mohr-Coulomb potential function with respect to the three invariants (psi in degrees).</p><p><strong>Function</strong></p><pre><code class="language-julia">(dq1,dq2,dq3) = mocouq(psi,dsbar,theta)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* psi::Float64               : Local force and momemts (Updated)
* dsbar::Float64             : Globale forces and moments
* theta::Float64             : Element orientation angle (3D)</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* dq1::Float64               : Local force and momemts (Updated)
* dq2::Float64               : Globale forces and moments
* dq3::Float64               : Element orientation angle (3D)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/mocouq.jl#L1-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.num_to_g!-Tuple{Array{Int64,1},Array{Int64,2},Array{Int64,1}}" href="#PtFEM.num_to_g!-Tuple{Array{Int64,1},Array{Int64,2},Array{Int64,1}}"><code>PtFEM.num_to_g!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>num_to_g!</strong></p><p>Returns the element steering vector g from the element node numbering num and the nodal freedom array nf.</p><p><strong>Function</strong></p><pre><code class="language-julia">num_to_g!(num, nf, g)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* num::Vector{Int}       : Node numbering vector
* nf::Matrix{Int}        : Nodal freedom array
* g::Vector{Int}         : Element steering vector (Updated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/num_to_g.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.pin_jointed!-Tuple{Array{Float64,2},Float64,Array{Float64,2}}" href="#PtFEM.pin_jointed!-Tuple{Array{Float64,2},Float64,Array{Float64,2}}"><code>PtFEM.pin_jointed!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>pin_jointed!</strong></p><p>This subroutine forms the global stiffness matrix of a general pin-joionted structural element (1-, 2- or 3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">pin_jointed!(km, ea, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* km::Matrix{Float64}       : Element stiffness matrix (Updated)
* ea::Float64               : Element stiffness
* coord::Matrix{Float64}}   : Element nodal coordinates</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/pin_jointed.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.rigid_jointed!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,1},Array{Int64,1},Int64,Array{Float64,2}}" href="#PtFEM.rigid_jointed!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,1},Array{Int64,1},Int64,Array{Float64,2}}"><code>PtFEM.rigid_jointed!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>rigid_jointed!</strong></p><p>This subroutine forms the global stiffness matrix of a general pin-joionted structural element (1-, 2- or 3-d).</p><p><strong>Function</strong></p><pre><code class="language-julia">rigid_jointed!(km, prop, gamma, etype, iel, coord)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* km::Matrix{Float64}       : Element stiffness matrix (Updated)
* prop::Matrix{Float64}     : Element properties
* gamma::Vector{Float64}    : Element orientations (3D)
* etype::Vector{Int}      : Element type vector
* iel::Int                : Element number
* coord::Matrix{Float64}}   : Element nodal coordinates</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/rigid_jointed.jl#L1-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.rod_km!-Tuple{Array{Float64,2},Float64,Float64}" href="#PtFEM.rod_km!-Tuple{Array{Float64,2},Float64,Float64}"><code>PtFEM.rod_km!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>rod_km!</strong></p><p>This subroutine forms the stiffness matrix of a 1-d &quot;rod&quot; fin_el.</p><p><strong>Function</strong></p><pre><code class="language-julia">rod_km!(km, ea, length)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* km::Matrix{Float64}       : Element stiffness matrix (Updated)
* ea::Float64               : Element stiffness
* ell::Float64              : Element length</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/rod_km.jl#L1-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.rod_mm!-Tuple{Array{Float64,2},Float64}" href="#PtFEM.rod_mm!-Tuple{Array{Float64,2},Float64}"><code>PtFEM.rod_mm!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>rod_mm!</strong></p><p>This subroutine forms the consistent mass matrix of a 1-d &quot;rod&quot; fin_el.</p><p><strong>Function</strong></p><pre><code class="language-julia">rod_mm!(km, ell)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* mm::Matrix{Float64}       : Element mass matrix (Updated)
* ell::Float64              : Element length</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/rod_mm.jl#L1-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.sample!" href="#PtFEM.sample!"><code>PtFEM.sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>sample!</strong></p><p>This subroutine returns the local coordinates and weighting coefficients of the integrating points.</p><p><strong>Function</strong></p><pre><code class="language-julia">sample!(fin_el, s, wt)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fin_el::FiniteElement      : Finite element type
* s::Matrix{Float64}        : Local coordinates (Updated)
* wt::Vector{Float64}       : Weighting coefficients (Updated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/sample_line.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.shape_der!-Tuple{Array{Float64,2},Array{Float64,2},Int64}" href="#PtFEM.shape_der!-Tuple{Array{Float64,2},Array{Float64,2},Int64}"><code>PtFEM.shape_der!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>shape_der!</strong></p><p>This subroutine produces derivatives of shape functions with respect to local coordinates.</p><p><strong>Function</strong></p><pre><code class="language-julia">shape_der!(der, point, i)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* der::Matrix{Float64}       : Function derivative (Updated)
* points::Matrix{Float64}    : Local coordinates of integration points
* i::Int                   : Integration point</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/shape_der.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.shape_fun!-Tuple{Array{Float64,1},Array{Float64,2},Int64}" href="#PtFEM.shape_fun!-Tuple{Array{Float64,1},Array{Float64,2},Int64}"><code>PtFEM.shape_fun!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>shape_fun!</strong></p><p>This subroutine produces derivatives of shape functions with respect to local coordinates.</p><p><strong>Function</strong></p><pre><code class="language-julia">shape_fun!(fun, point, i)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fun::Vector{Float64}       : Shape function (Updated)
* points::Matrix{Float64}    : Local coordinates of integration points
* i::Int                   : Integration point</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/shape_fun.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.stability-Tuple{SparseMatrixCSC{Float64,Int64},SparseMatrixCSC{Float64,Int64},Float64,Int64}" href="#PtFEM.stability-Tuple{SparseMatrixCSC{Float64,Int64},SparseMatrixCSC{Float64,Int64},Float64,Int64}"><code>PtFEM.stability</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>stability</strong></p><p>Function spabac! performs Cholesky forward and back-substitution on a symmetric skyline global matrix. The loads vector is updated.</p><p>###Arguments</p><pre><code class="language-julia">stability(gsm, ggm, tol, limit)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* gsm::SparseMatrixCSC{Float64,Int}   : Factored global stiffness matrix
* ggm::SparseMatrixCSC{Float64,Int}   : Factored geometric matrix
* tol::Float64                          : Convergence tolerance
* limit::Int                          : Iteration limit</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Main/stability.jl#L1-L20">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Geom-1" href="#PtFEM-Geom-1">PtFEM - Geom</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.geom_rect!" href="#PtFEM.geom_rect!"><code>PtFEM.geom_rect!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>geom_rect!</strong></p><p>This subroutine forms the coordinates and connectivity for a rectangular mesh of right angled triangular elements (3, 6, 10 or 15-node) or quadrilateral elements (4, 8 or 9-node) counting in the x- or y-dir. </p><p><strong>Method</strong></p><pre><code class="language-julia">geom_rect!(fin_el, iel, x_coords, y_coords, coord, num, dir)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fin_el::FiniteElement            : Shape of finite element
                                     (Trangle or Quadrilateral)
* iel::Int                       : Element number
* x_coords::FloatRange{Float64}    : x coordinates
* y_coords::FloatRange{Float64}    : y coordinates
* coord::Matrix{Float64}           : Nodal coordinates (Updated)
* num::Vector{Int}               : Node numbers (Updated)
* dir::Symbol                      : Node numbering direction</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Geom/geom_rect.jl#L1-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.hexahedron_xz!" href="#PtFEM.hexahedron_xz!"><code>PtFEM.hexahedron_xz!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>hexahedron_xz!</strong></p><p>This subroutine generates nodal coordinates and numbering for 8, 14 or 20-node &quot;bricks&quot; counting x-z planes in the y-direction. </p><p><strong>Method</strong></p><pre><code class="language-julia">hexahedron_xz!(iel, x_coords, y_coords, z_coords, coord, num)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* iel::Int                       : Element number
* x_coords::FloatRange{Float64}    : x coordinates
* y_coords::FloatRange{Float64}    : y coordinates
* z_coords::FloatRange{Float64}    : y coordinates
* coord::Matrix{Float64}           : Nodal coordinates (Updated)
* num::Vector{Int}               : Node numbers (Updated)
* dir::Symbol                      : Node numbering direction</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Geom/hexahedron_xz.jl#L1-L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mesh_size" href="#PtFEM.mesh_size"><code>PtFEM.mesh_size</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>mesh_size</strong></p><p>Function mesh_size returns the number of fin_els (nels) and the number of nodes (nn) in a 1, 2 or 3-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe, [nye[, nze]])</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* fin_el::FiniteElement   : Shape of finite element
                            1D: Line
                            2D: Trangle or Quadrilateral
                            3D: Hexahedron
* nxe::Int              : Number of fin_els in x direction
* nye::Int              : Number of fin_els in y direction (for 2D and 3D)
* nze::Int              : Number of fin_els in z direction (3D only)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Geom/mesh_size.jl#L1-L22">source</a><br/><div><p><strong>mesh_size</strong></p><p>mesh_size: The function mesh_size returns the number of fin_els (nels) and the number of nodes (nn) in a 2-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `fin_el` : Shape of 2D finite element (Triangle)
* `nxe` : Number of fin_els in x direction
* `nxe` : Number of fin_els in y direction</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Geom/mesh_size.jl#L31-L47">source</a><br/><div><p><strong>mesh_size</strong></p><p>mesh_size: The function mesh_size returns the number of fin_els (nels) and the number of nodes (nn) in a 2-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe, nye)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `fin_el` : Shape of 2D finite element (Quadrilateral)
* `nxe` : Number of fin_els in x direction
* `nye` : Number of fin_els in y direction</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Geom/mesh_size.jl#L64-L80">source</a><br/><div><p><strong>mesh_size</strong></p><p>mesh_size: The function mesh_size returns the number of fin_els (nels) and the number of nodes (nn) in a 3-d geometry-created mesh.</p><p><strong>Method</strong></p><pre><code class="language-julia">(nels, nn) = mesh_size(fin_el, nxe, nye, nze)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `fin_el` : Shape of 2D finite element (Hexahedron)
* `nxe` : Number of fin_els in x direction
* `nye` : Number of fin_els in y direction
* `nxe` : Number of fin_els in x direction</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Geom/mesh_size.jl#L97-L114">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Plot-methods-1" href="#PtFEM-Plot-methods-1">PtFEM - Plot methods</a></h2><pre><code class="language-none">PtFEM.mesh(data::Dict, g_coord::Array{Float64,2}, g_num::Array{Int, 2}, disp, ampl, pdir)</code></pre><h2><a class="nav-anchor" id="PtFEM-VTK-methods-1" href="#PtFEM-VTK-methods-1">PtFEM - VTK methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.vtk-Tuple{Dict,Any,Any,Any,Any}" href="#PtFEM.vtk-Tuple{Dict,Any,Any,Any,Any}"><code>PtFEM.vtk</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>vtk</strong></p><p>Plots displacements and directions</p><p><strong>Function</strong></p><pre><code class="language-julia">mesh(data, fm_dt, sigma_dt, dir, fname)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* data::Dict                 : Input dictionary
* fm_dt::DataTable           : Forces and moments DataTable
* sigma_dt::DataTable        : Stresses DataTable
* dir::AbstractString        : Project directory
* fname::AbstractString      : Output VTK file name</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/graphics/vtkrecipes/vtk.jl#L9-L27">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Julia-functions-and-operators-1" href="#PtFEM-Julia-functions-and-operators-1">PtFEM - Julia functions &amp; operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cholfact" href="#Base.LinAlg.cholfact"><code>Base.LinAlg.cholfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cholfact(A, [uplo::Symbol,] Val{false}) -&gt; Cholesky</code></pre><p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <code>Cholesky</code> factorization. The matrix <code>A</code> can either be a <a href="@ref"><code>Symmetric</code></a> or <a href="@ref"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. In the latter case, the optional argument <code>uplo</code> may be <code>:L</code> for using the lower part or <code>:U</code> for the upper part of <code>A</code>. The default is to use <code>:U</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>Cholesky</code> objects: <a href="@ref"><code>size</code></a>, <a href="index.html#Base.:\\"><code>\</code></a>, <a href="@ref"><code>inv</code></a>, and <a href="@ref"><code>det</code></a>. A <code>PosDefException</code> exception is thrown in case the matrix is not positive definite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholfact(A)
Base.LinAlg.Cholesky{Float64,Array{Float64,2}} with factor:
[2.0 6.0 -8.0; 0.0 1.0 5.0; 0.0 0.0 3.0]

julia&gt; C[:U]
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C[:L]
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C[:L] * C[:U] == A
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/ad290e93e4d10831c1be42cc706babaaeb49c19c/base/linalg/cholesky.jl#L297-L338">source</a><br/><div><pre><code class="language-none">cholfact(A, [uplo::Symbol,] Val{true}; tol = 0.0) -&gt; CholeskyPivoted</code></pre><p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <code>CholeskyPivoted</code> factorization. The matrix <code>A</code> can either be a <a href="@ref"><code>Symmetric</code></a> or <a href="@ref"><code>Hermitian</code></a> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. In the latter case, the optional argument <code>uplo</code> may be <code>:L</code> for using the lower part or <code>:U</code> for the upper part of <code>A</code>. The default is to use <code>:U</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>PivotedCholesky</code> objects: <a href="@ref"><code>size</code></a>, <a href="index.html#Base.:\\"><code>\</code></a>, <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>rank</code></a>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/ad290e93e4d10831c1be42cc706babaaeb49c19c/base/linalg/cholesky.jl#L363-L376">source</a><br/><div><pre><code class="language-none">cholfact(A; shift = 0.0, perm = Int[]) -&gt; CHOLMOD.Factor</code></pre><p>Compute the Cholesky factorization of a sparse positive definite matrix <code>A</code>. <code>A</code> must be a <code>SparseMatrixCSC</code>, <code>Symmetric{SparseMatrixCSC}</code>, or <code>Hermitian{SparseMatrixCSC}</code>. Note that even if <code>A</code> doesn&#39;t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code>F = cholfact(A)</code> is most frequently used to solve systems of equations with <code>F\b</code>, but also the methods <a href="@ref"><code>diag</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>logdet</code></a> are defined for <code>F</code>. You can also extract individual factors from <code>F</code>, using <code>F[:L]</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P&#39;*L*L&#39;*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it&#39;s typically preferable to extract &quot;combined&quot; factors like <code>PtL = F[:PtL]</code> (the equivalent of <code>P&#39;*L</code>) and <code>LtP = F[:UP]</code> (the equivalent of <code>L&#39;*P</code>).</p><p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is nonempty, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD&#39;s default AMD ordering).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p><p>Many other functions from CHOLMOD are wrapped but not exported from the <code>Base.SparseArrays.CHOLMOD</code> module.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/ad290e93e4d10831c1be42cc706babaaeb49c19c/base/sparse/cholmod.jl#L1405-L1437">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\" href="#Base.:\\"><code>Base.:\</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">\(x, y)</code></pre><p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p><pre><code class="language-julia-repl">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [1 2; 3 4]; x = [5, 6];

julia&gt; A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia&gt; inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/ad290e93e4d10831c1be42cc706babaaeb49c19c/base/operators.jl#L431-L456">source</a><br/><div><pre><code class="language-none">\(A, B)</code></pre><p>Matrix division using a polyalgorithm. For input matrices <code>A</code> and <code>B</code>, the result <code>X</code> is such that <code>A*X == B</code> when <code>A</code> is square. The solver that is used depends upon the structure of <code>A</code>.  If <code>A</code> is upper or lower triangular (or diagonal), no factorization of <code>A</code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p><p>For rectangular <code>A</code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code>A</code> and a rank estimate of <code>A</code> based on the R factor.</p><p>When <code>A</code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code>LDLt</code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 0; 1 -2]; B = [32; -4];

julia&gt; X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia&gt; A * X == B
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/ad290e93e4d10831c1be42cc706babaaeb49c19c/base/linalg/generic.jl#L774-L803">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Parallel-processing-1" href="#PtFEM-Parallel-processing-1">PtFEM - Parallel processing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Distributed.pmap" href="#Base.Distributed.pmap"><code>Base.Distributed.pmap</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pmap([::AbstractWorkerPool], f, c...; distributed=true, batch_size=1, on_error=nothing, retry_delays=[]), retry_check=nothing) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element using available workers and tasks.</p><p>For multiple collection arguments, apply <code>f</code> elementwise.</p><p>Note that <code>f</code> must be made available to all worker processes; see <a href="@ref">Code Availability and Loading Packages</a> for details.</p><p>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</p><p>By default, <code>pmap</code> distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify <code>distributed=false</code>. This is equivalent to using <a href="@ref"><code>asyncmap</code></a>. For example, <code>pmap(f, c; distributed=false)</code> is equivalent to <code>asyncmap(f,c; ntasks=()-&gt;nworkers())</code></p><p><code>pmap</code> can also use a mix of processes and tasks via the <code>batch_size</code> argument. For batch sizes greater than 1, the collection is processed in multiple batches, each of length <code>batch_size</code> or less. A batch is sent as a single request to a free worker, where a local <a href="@ref"><code>asyncmap</code></a> processes elements from the batch using multiple concurrent tasks.</p><p>Any error stops <code>pmap</code> from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument <code>on_error</code> which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</p><p>Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:</p><pre><code class="language-julia-repl">julia&gt; pmap(x-&gt;iseven(x) ? error(&quot;foo&quot;) : x, 1:4; on_error=identity)
4-element Array{Any,1}:
 1
  ErrorException(&quot;foo&quot;)
 3
  ErrorException(&quot;foo&quot;)

julia&gt; pmap(x-&gt;iseven(x) ? error(&quot;foo&quot;) : x, 1:4; on_error=ex-&gt;0)
4-element Array{Int64,1}:
 1
 0
 3
 0</code></pre><p>Errors can also be handled by retrying failed computations. Keyword arguments <code>retry_delays</code> and <code>retry_check</code> are passed through to <a href="@ref"><code>retry</code></a> as keyword arguments <code>delays</code> and <code>check</code> respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</p><p>Note that if both <code>on_error</code> and <code>retry_delays</code> are specified, the <code>on_error</code> hook is called before retrying. If <code>on_error</code> does not throw (or rethrow) an exception, the element will not be retried.</p><p>Example: On errors, retry <code>f</code> on an element a maximum of 3 times without any delay between retries.</p><pre><code class="language-julia">pmap(f, c; retry_delays = zeros(3))</code></pre><p>Example: Retry <code>f</code> only if the exception is not of type <code>InexactError</code>, with exponentially increasing delays up to 3 times. Return a <code>NaN</code> in place for all <code>InexactError</code> occurrences.</p><pre><code class="language-julia">pmap(f, c; on_error = e-&gt;(isa(e, InexactError) ? NaN : rethrow(e)), retry_delays = ExponentialBackOff(n = 3))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/ad290e93e4d10831c1be42cc706babaaeb49c19c/base/distributed/pmap.jl#L32-L98">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Deprecated-1" href="#PtFEM-Deprecated-1">PtFEM - Deprecated</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fkdiag!" href="#PtFEM.fkdiag!"><code>PtFEM.fkdiag!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>fkdiag!</strong></p><p>This subroutine returns the elastic dee matrix for ih=3 (plane strain), ih=4 (axisymmetry or plane strain elastoplasticity) or ih=6 (three dimensions).</p><p><strong>Method</strong></p><pre><code class="language-julia">fkdiag!(kdiag, g)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kdiag::Vector{Int}      : Bandwidth vector (Updated)
* g::Vector{Int}          : Element steering vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/fkdiag.jl#L1-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fromSkyline-Tuple{Array{Float64,1},Array{Int64,1}}" href="#PtFEM.fromSkyline-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.fromSkyline</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>fromSkyline</strong></p><p>Helper function to convert a Skyline vector to a full matrix.</p><p><strong>Type</strong></p><pre><code class="language-julia">fromSkyline(skyline::Vector{Float64}, kdiag::Vector{Int})</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* skyline::Vector{Float64}     : 1D Line(nod, nodof)
* kdiag::Vector{Int}         : 2D Triangle(nod, nodof)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/fromSkyline.jl#L1-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.fsparv!-Tuple{Array{Float64,1},Array{Float64,2},Array{Int64,1},Array{Int64,1}}" href="#PtFEM.fsparv!-Tuple{Array{Float64,1},Array{Float64,2},Array{Int64,1},Array{Int64,1}}"><code>PtFEM.fsparv!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>fsparv!</strong></p><p>Function fsparv! assembles fin_el matrices into a symmetric skyline global matrix. The Skyline vector kv is updated.</p><p><strong>Method</strong></p><pre><code class="language-julia">fsparv!(kv, km, g, km)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}        : Sparse stiffnes matrix (Updated)
* km::Matrix{Float64}        : Symmetric element stiffnes matrix
* g::Vector{Int}           : Global steering vector.
* kdiag::Vector{Int}       : Location of diagoinal terms</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/fsparv.jl#L1-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.linmul_sky!" href="#PtFEM.linmul_sky!"><code>PtFEM.linmul_sky!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>linmul_sky!</strong></p><p>This subroutine forms the product of symmetric matrix stored as a skyline and a vector.</p><p><strong>Method</strong></p><pre><code class="language-julia">linmul_sky!(kv, disps, loads, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Sparse stiffnes matrix (Skyline format)
* disps::Vector{Float64}    : Displacements
* loads::Vector{Float64}    : Loads vector (Updated)
* kdiag::Vector{Int}      : Bandwidth vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/linmul_sky.jl#L1-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.skyline2sparse-Tuple{Array{Float64,1},Array{Int64,1}}" href="#PtFEM.skyline2sparse-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.skyline2sparse</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>skyline2sparse</strong></p><p>Converts a Skyline matrix to a Julia Sparse matrix</p><p><strong>Function</strong></p><pre><code class="language-julia">skyline2sparse(skyline, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* skyline::Vector{Float64}         : Skyline matrix
* kdiag::Vector{Int}             : Element diagonal index vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/skyline2sparse.jl#L1-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.spabac!-Tuple{Array{Float64,1},Array{Float64,1},Array{Int64,1}}" href="#PtFEM.spabac!-Tuple{Array{Float64,1},Array{Float64,1},Array{Int64,1}}"><code>PtFEM.spabac!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>spabac!</strong></p><p>Function spabac! performs Cholesky forward and back-substitution on a symmetric skyline global matrix. The loads vector is updated.</p><p>###Arguments</p><pre><code class="language-julia">spabac!(kv, loads, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Skyline vector of global stiffness matrix
* loads::Vector{Float64}    : Load vector (Updated)
* kdiag::Vector{Int}      : Diagonal elemnt index vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/spabac.jl#L1-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.sparin!-Tuple{Array{Float64,1},Array{Int64,1}}" href="#PtFEM.sparin!-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.sparin!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>sparin!</strong></p><p>Function sparin! performs Cholesky factorisation on a symmetric skyline global matrix. The vector kv is updated.</p><p>###Arguments</p><pre><code class="language-julia">sparin!(kv, kdiag)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* kv::Vector{Float64}       : Global stiffness matrix (Updated)
* kdiag::Vector{Int}      : Diagonal elemnt index vector</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/abf9202a6041f7ac44984b345c299556288630c6/src/PtFEM/Deprecated/sparin.jl#L1-L18">source</a><br/></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="index.html#PtFEM.Beam"><code>PtFEM.Beam</code></a></li><li><a href="index.html#PtFEM.FEM"><code>PtFEM.FEM</code></a></li><li><a href="index.html#PtFEM.FiniteElement"><code>PtFEM.FiniteElement</code></a></li><li><a href="index.html#PtFEM.Frame"><code>PtFEM.Frame</code></a></li><li><a href="index.html#PtFEM.GenericSolid"><code>PtFEM.GenericSolid</code></a></li><li><a href="index.html#PtFEM.Hexahedron"><code>PtFEM.Hexahedron</code></a></li><li><a href="index.html#PtFEM.Line"><code>PtFEM.Line</code></a></li><li><a href="index.html#PtFEM.Plane"><code>PtFEM.Plane</code></a></li><li><a href="index.html#PtFEM.Quadrilateral"><code>PtFEM.Quadrilateral</code></a></li><li><a href="index.html#PtFEM.Rod"><code>PtFEM.Rod</code></a></li><li><a href="index.html#PtFEM.Solid"><code>PtFEM.Solid</code></a></li><li><a href="index.html#PtFEM.StructuralElement"><code>PtFEM.StructuralElement</code></a></li><li><a href="index.html#PtFEM.Tetrahedron"><code>PtFEM.Tetrahedron</code></a></li><li><a href="index.html#PtFEM.Triangle"><code>PtFEM.Triangle</code></a></li><li><a href="index.html#PtFEM.jFEM"><code>PtFEM.jFEM</code></a></li><li><a href="index.html#Base.:\\"><code>Base.:\</code></a></li><li><a href="index.html#Base.Distributed.pmap"><code>Base.Distributed.pmap</code></a></li><li><a href="index.html#Base.LinAlg.cholfact"><code>Base.LinAlg.cholfact</code></a></li><li><a href="index.html#PtFEM.beam_gm-Tuple{Float64}"><code>PtFEM.beam_gm</code></a></li><li><a href="index.html#PtFEM.beam_km-Tuple{Float64,Float64}"><code>PtFEM.beam_km</code></a></li><li><a href="index.html#PtFEM.beam_mm-Tuple{Float64,Float64}"><code>PtFEM.beam_mm</code></a></li><li><a href="index.html#PtFEM.beemat!-Tuple{Array{Float64,2},Array{Float64,2}}"><code>PtFEM.beemat!</code></a></li><li><a href="index.html#PtFEM.bmat_nonaxi!-Tuple{Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2},Array{Float64,1},Int64,Int64}"><code>PtFEM.bmat_nonaxi!</code></a></li><li><a href="index.html#PtFEM.checon-Tuple{Array{Float64,1},Array{Float64,1},Float64}"><code>PtFEM.checon</code></a></li><li><a href="index.html#PtFEM.deemat!-Tuple{Array{Float64,2},Float64,Float64}"><code>PtFEM.deemat!</code></a></li><li><a href="index.html#PtFEM.fkdiag!-Tuple{Array{Int64,1},Array{Int64,1}}"><code>PtFEM.fkdiag!</code></a></li><li><a href="index.html#PtFEM.fkdiag!"><code>PtFEM.fkdiag!</code></a></li><li><a href="index.html#PtFEM.fmplat!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Float64,Float64,Int64}"><code>PtFEM.fmplat!</code></a></li><li><a href="index.html#PtFEM.formm!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>PtFEM.formm!</code></a></li><li><a href="index.html#PtFEM.formnf!-Tuple{Int64,Int64,Array{Int64,2}}"><code>PtFEM.formnf!</code></a></li><li><a href="index.html#PtFEM.fromSkyline-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.fromSkyline</code></a></li><li><a href="index.html#PtFEM.fsparm!-Tuple{Any,Any,Any}"><code>PtFEM.fsparm!</code></a></li><li><a href="index.html#PtFEM.fsparv!-Tuple{Array{Float64,1},Array{Float64,2},Array{Int64,1},Array{Int64,1}}"><code>PtFEM.fsparv!</code></a></li><li><a href="index.html#PtFEM.geom_rect!"><code>PtFEM.geom_rect!</code></a></li><li><a href="index.html#PtFEM.glob_to_axial-Tuple{Array{Float64,1},Array{Float64,2}}"><code>PtFEM.glob_to_axial</code></a></li><li><a href="index.html#PtFEM.glob_to_loc!-Tuple{Array{Float64,1},Array{Float64,1},Float64,Array{Float64,2}}"><code>PtFEM.glob_to_loc!</code></a></li><li><a href="index.html#PtFEM.hexahedron_xz!"><code>PtFEM.hexahedron_xz!</code></a></li><li><a href="index.html#PtFEM.hinge!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,1},Array{Float64,1},Array{Float64,2},Any,Array{Int64,1},Array{Float64,1}}"><code>PtFEM.hinge!</code></a></li><li><a href="index.html#PtFEM.invar-Tuple{Array{Float64,1},Float64,Float64,Float64}"><code>PtFEM.invar</code></a></li><li><a href="index.html#PtFEM.linmul_sky!-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}"><code>PtFEM.linmul_sky!</code></a></li><li><a href="index.html#PtFEM.linmul_sky!"><code>PtFEM.linmul_sky!</code></a></li><li><a href="index.html#PtFEM.loc_to_glob!-Tuple{Array{Float64,1},Array{Float64,1},Float64,Array{Float64,2}}"><code>PtFEM.loc_to_glob!</code></a></li><li><a href="index.html#PtFEM.mesh_size"><code>PtFEM.mesh_size</code></a></li><li><a href="index.html#PtFEM.mocouf-NTuple{5,Any}"><code>PtFEM.mocouf</code></a></li><li><a href="index.html#PtFEM.mocouq-Tuple{Any,Any,Any}"><code>PtFEM.mocouq</code></a></li><li><a href="index.html#PtFEM.num_to_g!-Tuple{Array{Int64,1},Array{Int64,2},Array{Int64,1}}"><code>PtFEM.num_to_g!</code></a></li><li><a href="index.html#PtFEM.p41"><code>PtFEM.p41</code></a></li><li><a href="index.html#PtFEM.p42-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p42</code></a></li><li><a href="index.html#PtFEM.p43-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p43</code></a></li><li><a href="index.html#PtFEM.p44-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p44</code></a></li><li><a href="index.html#PtFEM.p45-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p45</code></a></li><li><a href="index.html#PtFEM.p46-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p46</code></a></li><li><a href="index.html#PtFEM.p47-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p47</code></a></li><li><a href="index.html#PtFEM.p51-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p51</code></a></li><li><a href="index.html#PtFEM.p52-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p52</code></a></li><li><a href="index.html#PtFEM.p61-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p61</code></a></li><li><a href="index.html#PtFEM.p62-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p62</code></a></li><li><a href="index.html#PtFEM.p63-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p63</code></a></li><li><a href="index.html#PtFEM.pin_jointed!-Tuple{Array{Float64,2},Float64,Array{Float64,2}}"><code>PtFEM.pin_jointed!</code></a></li><li><a href="index.html#PtFEM.rigid_jointed!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,1},Array{Int64,1},Int64,Array{Float64,2}}"><code>PtFEM.rigid_jointed!</code></a></li><li><a href="index.html#PtFEM.rod_km!-Tuple{Array{Float64,2},Float64,Float64}"><code>PtFEM.rod_km!</code></a></li><li><a href="index.html#PtFEM.rod_mm!-Tuple{Array{Float64,2},Float64}"><code>PtFEM.rod_mm!</code></a></li><li><a href="index.html#PtFEM.sample!"><code>PtFEM.sample!</code></a></li><li><a href="index.html#PtFEM.shape_der!-Tuple{Array{Float64,2},Array{Float64,2},Int64}"><code>PtFEM.shape_der!</code></a></li><li><a href="index.html#PtFEM.shape_fun!-Tuple{Array{Float64,1},Array{Float64,2},Int64}"><code>PtFEM.shape_fun!</code></a></li><li><a href="index.html#PtFEM.skyline2sparse-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.skyline2sparse</code></a></li><li><a href="index.html#PtFEM.spabac!-Tuple{Array{Float64,1},Array{Float64,1},Array{Int64,1}}"><code>PtFEM.spabac!</code></a></li><li><a href="index.html#PtFEM.sparin!-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.sparin!</code></a></li><li><a href="index.html#PtFEM.stability-Tuple{SparseMatrixCSC{Float64,Int64},SparseMatrixCSC{Float64,Int64},Float64,Int64}"><code>PtFEM.stability</code></a></li><li><a href="index.html#PtFEM.vtk-Tuple{Dict,Any,Any,Any,Any}"><code>PtFEM.vtk</code></a></li></ul><footer><hr/><a class="previous" href="CHANGES.html"><span class="direction">Previous</span><span class="title">Changes w.r.t. PtFEM</span></a><a class="next" href="VERSIONS.html"><span class="direction">Next</span><span class="title">Versions</span></a></footer></article></body></html>
