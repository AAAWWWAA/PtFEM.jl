<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PtFEM.jl documentation · PtFEM</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>PtFEM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="INTRO.html">Introduction</a></li><li><a class="toctext" href="GETTINGSTARTED.html">Getting started</a></li><li><a class="toctext" href="CHANGES.html">Changes w.r.t. PtFEM</a></li><li class="current"><a class="toctext" href="index.html">PtFEM.jl documentation</a><ul class="internal"><li><a class="toctext" href="#Static-Equilibrium-Programs-1">4 Static Equilibrium Programs</a></li><li><a class="toctext" href="#Elastic-Solids-Programs-1">5 Elastic Solids Programs</a></li><li><a class="toctext" href="#Material-Nonlinearity-Programs-1">6 Material Nonlinearity Programs</a></li><li><a class="toctext" href="#Structural-Element-Types-1">Structural Element Types</a></li><li><a class="toctext" href="#Finite-Element-Types-1">Finite Element Types</a></li><li><a class="toctext" href="#Other-Julia-Types-1">Other Julia Types</a></li><li><a class="toctext" href="#PtFEM-Main-1">PtFEM - Main</a></li><li><a class="toctext" href="#PtFEM-Geom-1">PtFEM - Geom</a></li><li><a class="toctext" href="#PtFEM-Plot-methods-1">PtFEM - Plot methods</a></li><li><a class="toctext" href="#PtFEM-VTK-methods-1">PtFEM - VTK methods</a></li><li><a class="toctext" href="#PtFEM-Julia-functions-and-operators-1">PtFEM - Julia functions &amp; operators</a></li><li><a class="toctext" href="#PtFEM-Parallel-processing-1">PtFEM - Parallel processing</a></li><li><a class="toctext" href="#PtFEM-No-longer-used-1">PtFEM - No longer used</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li><li><a class="toctext" href="VERSIONS.html">Versions</a></li><li><a class="toctext" href="TODO.html">Todo</a></li><li><a class="toctext" href="REFERENCES.html">References</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">PtFEM.jl documentation</a></li></ul><a class="edit-page" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Programs-1" href="#Programs-1">Programs</a></h1><h2><a class="nav-anchor" id="Static-Equilibrium-Programs-1" href="#Static-Equilibrium-Programs-1">4 Static Equilibrium Programs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p41" href="#PtFEM.p41"><code>PtFEM.p41</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Method p41</strong></p><p>One dimensional analysis of an axially loaded elastic Rod using 2-node  Line elements. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p41(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int64}         : Element material vector if np_types &gt; 1
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Rod                           : Help on a Rod structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p41.jl#L1-L49">source</a><br/><div><p><strong>Method p41</strong></p><p>One dimensional analysis of an axially loaded elastic Rod using 2-node  Line elements. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p41(m, data) # Re-use factored global stiffness matrix</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `m::jFEM`                  : Previously created jFEM model
* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int64}         : Element material vector if np_types &gt; 1
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Rod                           : Help on a Rod structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p41.jl#L271-L320">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p42-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p42-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p42</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p42</strong></p><p>Analysis of elastic pin-jointed frames using 2-node rod elements in 2- or 3-dimensions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p42(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of structural element
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::Vector{Float64}                            : x coordinate vector
* y_coords::Vector{Float64}                            : y coordinate vector
* g_num::Array{Int64,2}                                : Element node connections</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* penalty::Float64             : Penalty for fixed freedoms
* etype::Vector{Int64}         : Element material vector
* z_coords::Vector{Float64}    : z coordinate vector (3D)
* eq_nodal_forces_and_moments  : Contribution of distributed loads to loaded_nodes</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : List structural element types
?Frame              : Help on a Rod structural fin_el
?FiniteElement      : List finite element types
?Line               : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p42.jl#L1-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p43-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p43-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p43</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>p43</strong></p><p>Analysis of elastic beams using 2-node Beam structural elements and Line finite elements. Elastic foundation is optional.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p43(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::LinSpace{Float64}                          : x coordinate vector
* g_num::Array{Int64,2}                                : Element node connections
* fixed_freedoms::Array{Tuple{Vector{Int64}}           : Fixed freedoms</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int64}                                 : Element material vector
* penalty::Float64                                     : Penalty for fixed freedoms
* eq_nodal_forces_and_moments                          : Equivalent nodal loads</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (jfem, dis_dt, fm_dt)        : Tuple of jFem, dis_dt and fm_dt
                                 where:
                                    jfem::jFem    : Computational result type
                                    dis_dt        : Displacement data table
                                    fm_dt         : Forces and moments data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?Rod                : Help on a Rod structural fin_el
?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p43.jl#L1-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p44-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p44-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p44</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>p44</strong></p><p>Analysis of elastic rigid-joonted frames using a 2-node Frame structural element and Line finite elements in 2 or 3 dimensions.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p44(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x coordinate vector
* y_coords::FloatRange{Float64}                        : y coordinate vector
* g_num::Array{Int64,2}                                : Element node connections
* fixed_freedoms::Array{Tuple{Vector{Int64}}           : Fixed freedoms</code></pre><p><strong>Optional additional dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int64}                                 : Element material vector
* penalty::Float64                                     : Penalty for fixed freedoms
* z_coords::FloatRange{Float64}                        : z coordinate vector
* eq_nodal_forces_and_moments                          : Equivalent nodal loads</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement  : Help on structural elements
?Beam               : Help on a Beam structural fin_el
?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p44.jl#L1-L43">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p45-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p45-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p45</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p45</strong></p><p>Analysis of elasto-plastic beams or rigid-jointed frames using a 2-node Frame structural element in 1, 2 or 3 dimensions. </p><p><strong>Constructors</strong></p><pre><code class="language-julia">p45(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}`  : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural element
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector
* dload::FloatRange{Float64}                           : load steps</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20                 : Penalty used for fixed degrees of freedoms
* etype::Vector{Int64}           : Element material vector if np_types &gt; 1
* y_coords::FloatRange{Float64}  : y-coordinate vector (2D)
* z_coords::FloatRange{Float64}  : x-coordinate vector (3D)
* limit = 250                    : Iteration limit
* tol = 0.0001                   : Tolerance for iteration convergence</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Frame                         : Help on a Frame structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p45.jl#L1-L43">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p46-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p46-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p46</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p46</strong></p><p>Stability (buckling) analysis of elastic beams using a 2-node Beam structural element and Line finite elements. Elastic foundation is optional.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p46(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Type of  structural fin_el
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Float64}                        : x-coordinate vector</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* etype::Vector{Int64}         : Element material vector if np_types &gt; 1
* limit = 250                  : Iteration limit
* tol = 0.0001                 : Tolerance for iteration convergence</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Beam                          : Help on a Beam structural element
?FiniteElement                 : List finite element types
?Line                          : Help on Line finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p46.jl#L1-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.p47-Tuple{Dict{Symbol,Any}}" href="#PtFEM.p47-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p47</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Method p47</strong></p><p>Analysis of plates (Plane structural element) using 4-node Quadrilateral finite elements. Homogeneous material with identical elements. Mesh numbered in x or y direction.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">p47(data)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* `data::Dict{Symbol, Any}` : Dictionary containing all input data</code></pre><p><strong>Required data dictionary keys</strong></p><pre><code class="language-julia">* struc_el::StructuralElement                          : Structural element
* support::Array{Tuple{Int64,Array{Int64,1}},1}        : Fixed-displacements vector
* loaded_nodes::Array{Tuple{Int64,Array{Float64,1}},1} : Node load vector
* properties::Vector{Float64}                          : Material properties
* x_coords::FloatRange{Floalt64}                       : x-coordinate vector
* y_coords::FloatRange{Floalt64}                       : y-coordinate vector
* thickness:: Float64                                  : Thickness of plate</code></pre><p><strong>Optional additional data dictionary keys</strong></p><pre><code class="language-julia">* penalty = 1e20               : Penalty used for fixed degrees of freedoms
* etype::Vector{Int64}         : Element material vector if np_types &gt; 1</code></pre><p><strong>Return values</strong></p><pre><code class="language-julia">* (fm_dt, sigma_dt)            : Tuple of jFem, dis_dt and fm_dt
                                  where:
                                    fm_dt         : Forces and moments data table
                                    sigma_dt      : Stresses data table</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?StructuralElement             : List of available structural element types
?Plane                         : Help on a Plane structural element
?FiniteElement                 : List finite element types
?Quadrilateral                 : Help on Quadrilateral finite element</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/4 Static Equilibrium/p47.jl#L1-L49">source</a><br/></section><h2><a class="nav-anchor" id="Elastic-Solids-Programs-1" href="#Elastic-Solids-Programs-1">5 Elastic Solids Programs</a></h2><pre><code class="language-none">p51(data::Dict{Symbol, Any})
p52(data::Dict{Symbol, Any})
p53(data::Dict{Symbol, Any})
p54(data::Dict{Symbol, Any})
p55(data::Dict{Symbol, Any})
p56(data::Dict{Symbol, Any})</code></pre><h2><a class="nav-anchor" id="Material-Nonlinearity-Programs-1" href="#Material-Nonlinearity-Programs-1">6 Material Nonlinearity Programs</a></h2><pre><code class="language-none">p61(data::Dict{Symbol, Any})
p62(data::Dict{Symbol, Any})</code></pre><h2><a class="nav-anchor" id="Structural-Element-Types-1" href="#Structural-Element-Types-1">Structural Element Types</a></h2><pre><code class="language-none">StructuralElement
Rod
Beam
Frame
Plane
Solid
GenericSolid</code></pre><h2><a class="nav-anchor" id="Finite-Element-Types-1" href="#Finite-Element-Types-1">Finite Element Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.FiniteElement" href="#PtFEM.FiniteElement"><code>PtFEM.FiniteElement</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>FiniteElement</strong></p><p>Abstract finite element type.</p><p><strong>Type</strong></p><pre><code class="language-julia">abstract FiniteElement</code></pre><p><strong>Subtypes</strong></p><pre><code class="language-julia">* Line::FiniteElement          : 1D Line(nod, nodof)
* Triangle::FiniteElement      : 2D Triangle(nod, nodof)
* Quadrilateral::FiniteElement : 2D Quadrilateral(nod, nodof)
* Hexahedron::FiniteElement    : 3D Hexahedron(nod, nodof)
* Tetrahedron::FiniteElement   : 3D Tetrahedron(nod, nodof)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/PtFEM/Types/finite_elements.jl#L5-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Line" href="#PtFEM.Line"><code>PtFEM.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Line (Interval)</strong></p><p>1D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Line(nod, nodof)
Line(nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int64       : Number of nodes for finite element, defaults to 2
* nodof::Int64     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/PtFEM/Types/finite_elements.jl#L26-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Triangle" href="#PtFEM.Triangle"><code>PtFEM.Triangle</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Triangle</strong></p><p>2D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Triangle(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int64       : Number of nodes for finite element (3, 6, 10, 15)
* nodof::Int64     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/PtFEM/Types/finite_elements.jl#L55-L76">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Quadrilateral" href="#PtFEM.Quadrilateral"><code>PtFEM.Quadrilateral</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Quadrilateral</strong></p><p>2D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Quadrilateral(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int64       : Number of nodes for finite element (4, 8, 9)
* nodof::Int64     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/PtFEM/Types/finite_elements.jl#L82-L103">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Hexahedron" href="#PtFEM.Hexahedron"><code>PtFEM.Hexahedron</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>hexahedron</strong></p><p>3D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Hexahedron(nod, nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int64       : Number of nodes for finite element (8, 14, 20)
* nodof::Int64     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/PtFEM/Types/finite_elements.jl#L138-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.Tetrahedron" href="#PtFEM.Tetrahedron"><code>PtFEM.Tetrahedron</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Tetrahedron</strong></p><p>3D type finite element</p><p><strong>Constructor</strong></p><pre><code class="language-julia">Tetrahedron(nod, nodof)
Tetrahedron(nodof)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* nod::Int64       : Number of nodes for finite element (defaults to 4)
* nodof::Int64     : Number of degrees of freedom per node</code></pre><p><strong>Related help</strong></p><pre><code class="language-julia">?FiniteElement      : Help on finite element types</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/PtFEM/Types/finite_elements.jl#L109-L131">source</a><br/></section><h2><a class="nav-anchor" id="Other-Julia-Types-1" href="#Other-Julia-Types-1">Other Julia Types</a></h2><pre><code class="language-none">FEM
jFEM</code></pre><h2><a class="nav-anchor" id="PtFEM-Main-1" href="#PtFEM-Main-1">PtFEM - Main</a></h2><pre><code class="language-none">PtFEM.beam_gm!(gm::Matrix{Float64}, ell::Float64)
PtFEM.beam_km!(km::Matrix{Float64}, ei::Float64, ell::Float64)
PtFEM.beam_mm!(mm::Matrix{Float64}, fs::Float64, ell::Float64)
PtFEM.beemat_nonaxi!(bee::Matrix{Float64}, radius::Float64, coord::Matrix{Float64}, deriv::Matrix{Float64}, fun::Vector{Float64}, iflag::Int64, lth::Int64)
PtFEM.beemat!(bee::Matrix{Float64},deriv::Matrix{Float64})
PtFEM.checon!(loads::Vector{Float64}, oldlds::Vector{Float64}, tol::Float64)
PtFEM.deemat!(dee::Array{Float64, 2}, e::Float64, v::Float64)
PtFEM.fkdiag!(ndof::Int64, neq::Int64, g::Vector{Int64}, kdiag::Vector{Int64})
PtFEM.fkdiag!(kdiag::Vector{Int64}, g::Vector{Int64})
PtFEM.fmplat!(d2x::Vector{Float64}, d2y::Vector{Float64}, d2xy::Vector{Float64}, points::Matrix{Float64}, aa::Float64, bb::Float64, i::Int64)
PtFEM.formm!(stress::Vector{Float64}, m1::Matrix{Float64}, m2::Matrix{Float64}, m3::Matrix{Float64})
PtFEM.formnf!(nodof::Int64, nn::Int64, nf::Matrix{Int64})
PtFEM.glob_to_loc!(loc::Vector{Float64}, glob::Vector{Float64}, gamma::Float64, coord::Matrix{Float64})
PtFEM.global_to_axial(glob::Vector{Float64}, coord::Matrix{Float64})
PtFEM.hinge!(coord::Matrix{Float64}, holdr::Matrix{Float64}, action::Vector{Float64}, react::Vector{Float64}, prop::Matrix{Float64}, iel, etype::Vector{Int64}, gamma::Vector{Float64})
PtFEM.invar!(stress::Vector{Float64}, sigm::Float64, dsbar::Float64, theta::Float64)
PtFEM.linmul_sky!(kv::Vector{Float64}, disps::Vector{Float64}, loads::Vector{Float64}, kdiag::Vector{Int64})
PtFEM.loc_to_glob!(loc::Vector{Float64}, glob::Vector{Float64}, gamma::Float64, coord::Matrix{Float64})
PtFEM.num_to_g!(num::Vector{Int64}, nf::Matrix{Int64}, g::Vector{Int64})
PtFEM.pin_jointed!(km::Matrix{Float64}, ea::Float64, coord::Matrix{Float64})
PtFEM.rigid_jointed!(km::Matrix{Float64}, prop::Matrix{Float64}, gamma::Vector{Float64}, etype::Vector{Int64}, iel::Int64, coord::Matrix{Float64})
PtFEM.rod_km!(km::Matrix{Float64}, ea::Float64, length::Float64)
PtFEM.format_nf_line!(l::AbstractString, t::Array{Tuple})
PtFEM.read_nf_file(f::AbstractString)
PtFEM.format_loads_line!(l::AbstractString, t::Array{Tuple})
PtFEM.read_loads_file(f::AbstractString)
PtFEM.rod_mm!(mm::Matrix{Float64}, length::Float64)
PtFEM.sample!(fin_el::Hexahedron, s::Matrix{Float64} , wt::Vector{Float64})
PtFEM.sample!(fin_el::Line, s::Matrix{Float64} , wt::Vector{Float64})
PtFEM.sample!(fin_el::Quadrilateral, s::Matrix{Float64} , wt::Vector{Float64})
PtFEM.sample!(fin_el::Tetrahedron, s::Matrix{Float64} , wt::Vector{Float64})
PtFEM.sample!(fin_el::Triangle, s::Matrix{Float64} , wt::Vector{Float64})
PtFEM.shape_der!(der::Matrix{Float64}, points::Matrix{Float64}, i::Int64)
PtFEM.shape_fun!(fun::Vector{Float64}, points::Matrix{Float64}, i::Int64)
PtFEM.stability(gsm::SparseMatrixCSC{Float64,Int64}, ggm::SparseMatrixCSC{Float64,Int64}, tol::Float64, limit::Int64)</code></pre><h2><a class="nav-anchor" id="PtFEM-Geom-1" href="#PtFEM-Geom-1">PtFEM - Geom</a></h2><pre><code class="language-none">PtFEM.geom_rect!(fin_el::Quadrilateral, iel::Int64, x_coords::Array{Float64, 1}, y_coords::Array{Float64, 1}, coord::Matrix{Float64}, num::Vector{Int64}, dir::Symbol)
PtFEM.geom_rect!(fin_el::Triangle, iel::Int64, x_coords::Array{Float64, 1}, y_coords::Array{Float64, 1}, coord::Matrix{Float64}, num::Vector{Int64}, dir::Symbol)
hexahedron_xz!(iel::Int64, x_coords::Vector{Float64}, y_coords::Vector{Float64}, z_coords::Vector{Float64}, coord::Matrix{Float64}, num::Vector{Int64})
PtFEM.mesh_size(fe::Line, nxe::Int64)
PtFEM.mesh_size(fe::Triangle, nxe::Int64, nye::Int64)
PtFEM.mesh_size(fe::Quadrilateral, nxe::Int64, nye::Int64)
PtFEM.mesh_size(fe::Hexahedron, nxe::Int64, nye::Int64, nze::Int64)</code></pre><h2><a class="nav-anchor" id="PtFEM-Plot-methods-1" href="#PtFEM-Plot-methods-1">PtFEM - Plot methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PtFEM.mesh-Tuple{Dict,Array{Float64,2},Array{Int64,2},Any,Any,Any}" href="#PtFEM.mesh-Tuple{Dict,Array{Float64,2},Array{Int64,2},Any,Any,Any}"><code>PtFEM.mesh</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>mesh</strong></p><p>Plots displacements and directions</p><p><strong>Function</strong></p><pre><code class="language-julia">mesh(data, g_coord, g_num, disp, ampl, pdir)</code></pre><p><strong>Arguments</strong></p><pre><code class="language-julia">* data::Dict                 : Input dictionary
* g_coord::Array{Float64, 2} : Coordinate array
* g_num::Array{Int, 2}       : Global node numbering array
* disp::DataTable            : Displacements DataTable
* ampl::Float64              : Amplification for derivatives
* pdir::AbstractString       : Nodal freedom matrix (updated)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/PtFEM/PtFEM.jl/tree/d0726c1ff41a87b6f128f3487deedb8ca74bd1d7/src/graphics/plotrecipes/mesh.jl#L4-L23">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-VTK-methods-1" href="#PtFEM-VTK-methods-1">PtFEM - VTK methods</a></h2><pre><code class="language-none">PtFEM.vtk(data::Dict, fm_dt, sigma_dt, dir, fname)</code></pre><h2><a class="nav-anchor" id="PtFEM-Julia-functions-and-operators-1" href="#PtFEM-Julia-functions-and-operators-1">PtFEM - Julia functions &amp; operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.cholfact" href="#Base.LinAlg.cholfact"><code>Base.LinAlg.cholfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cholfact(A, [uplo::Symbol,] Val{false}) -&gt; Cholesky</code></pre><p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <code>Cholesky</code> factorization. The matrix <code>A</code> can either be a <code>Symmetric</code> or <code>Hermitian</code> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. In the latter case, the optional argument <code>uplo</code> may be <code>:L</code> for using the lower part or <code>:U</code> for the upper part of <code>A</code>. The default is to use <code>:U</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>Cholesky</code> objects: <code>size</code>, <code>\</code>, <code>inv</code>, <code>det</code>. A <code>PosDefException</code> exception is thrown in case the matrix is not positive definite.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6445c82d0060dbe82b88436f0f4371a4ee64d918/base/linalg/cholesky.jl#L259-L270">source</a><br/><div><pre><code class="language-none">cholfact(A, [uplo::Symbol,] Val{true}; tol = 0.0) -&gt; CholeskyPivoted</code></pre><p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <code>CholeskyPivoted</code> factorization. The matrix <code>A</code> can either be a <code>Symmetric</code> or <code>Hermitian</code> <code>StridedMatrix</code> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. In the latter case, the optional argument <code>uplo</code> may be <code>:L</code> for using the lower part or <code>:U</code> for the upper part of <code>A</code>. The default is to use <code>:U</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F[:L]</code> and <code>F[:U]</code>. The following functions are available for <code>PivotedCholesky</code> objects: <code>size</code>, <code>\</code>, <code>inv</code>, <code>det</code>, and <code>rank</code>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6445c82d0060dbe82b88436f0f4371a4ee64d918/base/linalg/cholesky.jl#L295-L307">source</a><br/><div><pre><code class="language-none">cholfact(A; shift = 0.0, perm = Int[]) -&gt; CHOLMOD.Factor</code></pre><p>Compute the Cholesky factorization of a sparse positive definite matrix <code>A</code>. <code>A</code> must be a <code>SparseMatrixCSC</code>, <code>Symmetric{SparseMatrixCSC}</code>, or <code>Hermitian{SparseMatrixCSC}</code>. Note that even if <code>A</code> doesn&#39;t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code>F = cholfact(A)</code> is most frequently used to solve systems of equations with <code>F\b</code>, but also the methods <code>diag</code>, <code>det</code>, <code>logdet</code> are defined for <code>F</code>. You can also extract individual factors from <code>F</code>, using <code>F[:L]</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P&#39;*L*L&#39;*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it&#39;s typically preferable to extact &quot;combined&quot; factors like <code>PtL = F[:PtL]</code> (the equivalent of <code>P&#39;*L</code>) and <code>LtP = F[:UP]</code> (the equivalent of <code>L&#39;*P</code>).</p><p>Setting optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is nonempty, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD&#39;s default AMD ordering).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{Complex128}</code> as appropriate.</p><p>Many other functions from CHOLMOD are wrapped but not exported from the <code>Base.SparseArrays.CHOLMOD</code> module.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6445c82d0060dbe82b88436f0f4371a4ee64d918/base/sparse/cholmod.jl#L1323-L1354">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:\\" href="#Base.:\\"><code>Base.:\</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">\(x, y)</code></pre><p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6445c82d0060dbe82b88436f0f4371a4ee64d918/base/docs/helpdb/Base.jl#L5557-L5562">source</a><br/><div><pre><code class="language-none">\(A, B)</code></pre><p>Matrix division using a polyalgorithm. For input matrices <code>A</code> and <code>B</code>, the result <code>X</code> is such that <code>A*X == B</code> when <code>A</code> is square. The solver that is used depends upon the structure of <code>A</code>.  If <code>A</code> is upper or lower triangular (or diagonal), no factorization of <code>A</code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p><p>For rectangular <code>A</code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code>A</code> and a rank estimate of <code>A</code> based on the R factor.</p><p>When <code>A</code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code>LDLt</code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6445c82d0060dbe82b88436f0f4371a4ee64d918/base/linalg/generic.jl#L332-L347">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-Parallel-processing-1" href="#PtFEM-Parallel-processing-1">PtFEM - Parallel processing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pmap" href="#Base.pmap"><code>Base.pmap</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pmap([::AbstractWorkerPool], f, c...; distributed=true, batch_size=1, on_error=nothing, retry_n=0, retry_max_delay=DEFAULT_RETRY_MAX_DELAY, retry_on=DEFAULT_RETRY_ON) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element using available workers and tasks.</p><p>For multiple collection arguments, apply f elementwise.</p><p>Note that <code>f</code> must be made available to all worker processes; see <a href=":ref:`Code Availability and Loading Packages &lt;man-parallel-computing-code-availability&gt;`">Code Availability and Loading Packages</a> for details.</p><p>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</p><p>By default, <code>pmap</code> distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify <code>distributed=false</code>. This is equivalent to <code>asyncmap</code>.</p><p><code>pmap</code> can also use a mix of processes and tasks via the <code>batch_size</code> argument. For batch sizes greater than 1, the collection is split into multiple batches, which are distributed across workers. Each such batch is processed in parallel via tasks in each worker. The specified <code>batch_size</code> is an upper limit, the actual size of batches may be smaller and is calculated depending on the number of workers available and length of the collection.</p><p>Any error stops pmap from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument <code>on_error</code> which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</p><p>Failed computation can also be retried via <code>retry_on</code>, <code>retry_n</code>, <code>retry_max_delay</code>, which are passed through to <code>retry</code> as arguments <code>retry_on</code>, <code>n</code> and <code>max_delay</code> respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</p><p>The following are equivalent:</p><ul><li><p><code>pmap(f, c; distributed=false)</code> and <code>asyncmap(f,c)</code></p></li><li><p><code>pmap(f, c; retry_n=1)</code> and <code>asyncmap(retry(remote(f)),c)</code></p></li><li><p><code>pmap(f, c; retry_n=1, on_error=e-&gt;e)</code> and <code>asyncmap(x-&gt;try retry(remote(f))(x) catch e; e end, c)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/6445c82d0060dbe82b88436f0f4371a4ee64d918/base/pmap.jl#L33-L72">source</a><br/></section><h2><a class="nav-anchor" id="PtFEM-No-longer-used-1" href="#PtFEM-No-longer-used-1">PtFEM - No longer used</a></h2><pre><code class="language-none">PtFEM.sparin!(kv::Vector{Float64}, kdiag::Vector{Int64})
PtFEM.spabac!(kv::Vector{Float64}, loads::Vector{Float64}, kdiag::Vector{Int64})
fromSkyline(skyline::Vector{Float64}, kdiag::Vector{Int64})
PtFEM.skyline2sparse(skyline::Vector{Float64}, kdiag::Vector{Int64})
PtFEM.stability!(kv::Vector{Float64}, gv::Vector{Float64}, kdiag::Vector{Int64}, tol::Float64, limit::Int64, iters::Int64, evec::Vector{Float64}, ival::Float64)</code></pre><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="index.html#PtFEM.Beam"><code>PtFEM.Beam</code></a></li><li><a href="index.html#PtFEM.FiniteElement"><code>PtFEM.FiniteElement</code></a></li><li><a href="index.html#PtFEM.Hexahedron"><code>PtFEM.Hexahedron</code></a></li><li><a href="index.html#PtFEM.Line"><code>PtFEM.Line</code></a></li><li><a href="index.html#PtFEM.Quadrilateral"><code>PtFEM.Quadrilateral</code></a></li><li><a href="index.html#PtFEM.Rod"><code>PtFEM.Rod</code></a></li><li><a href="index.html#PtFEM.StructuralElement"><code>PtFEM.StructuralElement</code></a></li><li><a href="index.html#PtFEM.Tetrahedron"><code>PtFEM.Tetrahedron</code></a></li><li><a href="index.html#PtFEM.Triangle"><code>PtFEM.Triangle</code></a></li><li><a href="index.html#Base.:\\"><code>Base.:\</code></a></li><li><a href="index.html#Base.LinAlg.cholfact"><code>Base.LinAlg.cholfact</code></a></li><li><a href="index.html#Base.pmap"><code>Base.pmap</code></a></li><li><a href="index.html#PtFEM.formnf!-Tuple{Int64,Int64,Array{Int64,2}}"><code>PtFEM.formnf!</code></a></li><li><a href="index.html#PtFEM.mesh-Tuple{Dict,Array{Float64,2},Array{Int64,2},Any,Any,Any}"><code>PtFEM.mesh</code></a></li><li><a href="index.html#PtFEM.mesh_size-Tuple{PtFEM.Line,Int64}"><code>PtFEM.mesh_size</code></a></li><li><a href="index.html#PtFEM.mesh_size-Tuple{PtFEM.Quadrilateral,Int64,Int64}"><code>PtFEM.mesh_size</code></a></li><li><a href="index.html#PtFEM.mesh_size-Tuple{PtFEM.Triangle,Int64,Int64}"><code>PtFEM.mesh_size</code></a></li><li><a href="index.html#PtFEM.mesh_size-Tuple{PtFEM.Hexahedron,Int64,Int64,Int64}"><code>PtFEM.mesh_size</code></a></li><li><a href="index.html#PtFEM.p41"><code>PtFEM.p41</code></a></li><li><a href="index.html#PtFEM.p42-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p42</code></a></li><li><a href="index.html#PtFEM.p43-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p43</code></a></li><li><a href="index.html#PtFEM.p44-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p44</code></a></li><li><a href="index.html#PtFEM.p45-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p45</code></a></li><li><a href="index.html#PtFEM.p46-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p46</code></a></li><li><a href="index.html#PtFEM.p47-Tuple{Dict{Symbol,Any}}"><code>PtFEM.p47</code></a></li><li><a href="index.html#PtFEM.spabac!-Tuple{Array{Float64,1},Array{Float64,1},Array{Int64,1}}"><code>PtFEM.spabac!</code></a></li><li><a href="index.html#PtFEM.sparin!-Tuple{Array{Float64,1},Array{Int64,1}}"><code>PtFEM.sparin!</code></a></li></ul><footer><hr/><a class="previous" href="CHANGES.html"><span class="direction">Previous</span><span class="title">Changes w.r.t. PtFEM</span></a><a class="next" href="VERSIONS.html"><span class="direction">Next</span><span class="title">Versions</span></a></footer></article></body></html>
